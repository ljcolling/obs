// src/index.ts
// Main module file for Observable with WASM integration

// WASM module will be generated by wasm-pack
// Import the WASM bindings (these will be generated)
import init, * as wasm from '../pkg/my_wasm_module';

/**
 * WASM Module wrapper with Observable-friendly API
 */
export class WasmProcessor {
  private static initialized = false;
  private static wasmModule: any = null;

  /**
   * Initialize the WASM module
   * This needs to be called before using any WASM functions
   */
  static async init(wasmUrl?: string): Promise<void> {
    if (this.initialized) return;

    try {
      // For Observable, we need to provide the WASM file URL
      if (wasmUrl) {
        this.wasmModule = await init(wasmUrl);
      } else {
        // Try to load from the same origin
        this.wasmModule = await init();
      }
      this.initialized = true;
    } catch (error) {
      console.error('Failed to initialize WASM module:', error);
      throw new Error('WASM initialization failed');
    }
  }

  /**
   * Check if WASM module is initialized
   */
  static isInitialized(): boolean {
    return this.initialized;
  }

  /**
   * Example: Process array data with WASM
   */
  static processArray(data: Float64Array): Float64Array {
    if (!this.initialized) {
      throw new Error('WASM module not initialized. Call WasmProcessor.init() first.');
    }
    
    // Example WASM function call
    // Replace with your actual WASM functions
    return wasm.process_array(data);
  }

  /**
   * Example: Fast mathematical operations
   */
  static fastMath(a: number, b: number): number {
    if (!this.initialized) {
      throw new Error('WASM module not initialized. Call WasmProcessor.init() first.');
    }
    
    return wasm.fast_math_operation(a, b);
  }

  /**
   * Example: String processing with WASM
   */
  static processString(input: string): string {
    if (!this.initialized) {
      throw new Error('WASM module not initialized. Call WasmProcessor.init() first.');
    }
    
    return wasm.process_string(input);
  }
}

/**
 * High-level data processing utilities that use WASM under the hood
 */
export class FastDataProcessor {
  private data: Float64Array;

  constructor(data: number[] | Float64Array) {
    this.data = data instanceof Float64Array ? data : new Float64Array(data);
  }

  /**
   * Apply WASM-accelerated processing
   */
  async process(): Promise<Float64Array> {
    if (!WasmProcessor.isInitialized()) {
      throw new Error('WASM module not initialized. Call WasmProcessor.init() first.');
    }
    
    return WasmProcessor.processArray(this.data);
  }

  /**
   * Get original data
   */
  getData(): Float64Array {
    return this.data;
  }

  /**
   * Convert to regular array for Observable compatibility
   */
  toArray(): number[] {
    return Array.from(this.data);
  }
}

/**
 * Observable-friendly utilities that don't require WASM
 */
export const ObservableUtils = {
  /**
   * Create a WASM-compatible data loader
   */
  async loadWasmModule(wasmUrl: string): Promise<void> {
    await WasmProcessor.init(wasmUrl);
  },

  /**
   * Check WASM support in current environment
   */
  supportsWasm(): boolean {
    return typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function';
  },

  /**
   * Generate test data for WASM processing
   */
  generateTestData(size: number): Float64Array {
    const data = new Float64Array(size);
    for (let i = 0; i < size; i++) {
      data[i] = Math.random() * 100;
    }
    return data;
  },

  /**
   * Format large numbers for display
   */
  formatLargeNumber(num: number): string {
    if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
    if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
    return num.toString();
  }
};

/**
 * Performance monitoring utilities
 */
export class PerformanceMonitor {
  private startTime: number = 0;
  private measurements: Map<string, number[]> = new Map();

  start(): void {
    this.startTime = performance.now();
  }

  end(label: string): number {
    const duration = performance.now() - this.startTime;
    
    if (!this.measurements.has(label)) {
      this.measurements.set(label, []);
    }
    this.measurements.get(label)!.push(duration);
    
    return duration;
  }

  getStats(label: string): { avg: number; min: number; max: number; count: number } | null {
    const measurements = this.measurements.get(label);
    if (!measurements || measurements.length === 0) return null;

    const avg = measurements.reduce((a, b) => a + b) / measurements.length;
    const min = Math.min(...measurements);
    const max = Math.max(...measurements);
    
    return { avg, min, max, count: measurements.length };
  }

  clear(): void {
    this.measurements.clear();
  }
}

// Default export for convenience
export default {
  WasmProcessor,
  FastDataProcessor,
  ObservableUtils,
  PerformanceMonitor
};
